.............................................................................................
.............................................................................................
WeakSorter.java
    >> Dirección
    >> Umbral
    >> Pixel

StrongSorter.java
    >> Método Adaboost
    >> Métodos Enunciado

.............................................................................................
.............................................................................................
Adaboost (x , y)

    N = size(x);
    D(N) = 1 / N;   
    listaClasificadorDebil = {...}
    listaConfianza = {...}
    
    for( i = 0 >> T )
    {
        mejorClasificadorDebil = null;
        menorErr = INF;


        for( k = 0 >> A)
        {

            Pf = GenerarClasificadorAzar(DIMENSION);
            errK = obtenerErrorClasificador(Pf, x, y, D);
            
            if( errk < menorErr )
            {
                menorErr = errk;
                mejorClasificadorDebil = Pf;
            }
        }

        listaClasificadorDebil.add(mejorClasificadorDebil);
        a = o, s lm(1 - menorErr / menorErr);        
        listaConfianza.add(a);

        z = 0;

        auxD = D;
        
        for(i = 0 >> N)
        {
            exp = -1 * a * y[i].aplicarClasificadorDebil(mejorClasificadorDebil, x[i]);
            auxD[i] = nuevoPeso;
            z += nuevoPeso;
        }

        for( i = 0 >> N)
        {
            auxD[i] = auxD[i] / z;
        }

        D = auxD;
    }

return new (ClasificadorRobusto(listaClasificadorDebil, listaConfianzas));

.............................................................................................
.............................................................................................

>> generarClasificadorAzar(DIM)
   {
        pixel = rand(0 .. DIM);
        direcc = rand(1 .. 0);
        umbral = rand(min .. max); //0 .. 255
        
     return new ClasificadorDebil(pixel, direcc, umbral);
   }


>> obtenerErrClasif(Pf, x, y, D)
   {
        error = 0;
        for( i  = 0 >> size() )
        {
            res = aplicarClasificadorDebil(Pf, x[i]);
            if( res != y[i] )
            {
                error += D[i];
            }
        }

     return error;
   }

>> aplicarClasificadorDebil(Pf, imagen)
   {
        valido = -1;
        if(Pf. direccion)
        {
            if(imagen[pixel] <= Pf.umbral )
            {
                valido = 1;
            } 
        }
        else
        {
            if(imagen[pixel] > Pf.umbral )
            {
                valido = 1;
            }
        }

     return valido;
   }


























