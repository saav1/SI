
Adaboost.
    2.1 Clasificadores débiles.

    Teniendo en cuenta que cada imagén se especifica por un vector característico del mismo 
    tamaño que la imagen, 28 * 28 = 784. Podemos establecer que la imágenes, representadas
    por su vector característico, se van a encontrar distribuidas en un espacio de 784 
    dimensiones. El objetivo final de la práctica es encontrar un clasificador robusto que 
    divida este espacio de manera que se distinga la parte del espacio en la que está un 
    dígito concreto.

    Para obtener este clasificador robusto, vamos a comenzar por crear clasificadores no tan 
    robustos, pero que al menos nos sirvan para realizar una clasificación. Estos 
    clasificdores se conocen como clasificadores débiles.

    La forma más sencilla de clasificar objetos distribuidos en un espacio es dividir el 
    espacio en dos partes y especificar que los objetos que quedan a un lado se van a 
    clasificar según una clase y los obejtos que quedan al otro lado según otra clase. 
    Esto es posible realizarlo de manera muy sencilla utilizando un umbral. Los umbrales 
    pueden tener dos direcciones distintas y especifican para un determinado pixel el 
    rango aceptable del mismo. 

    Para obtener un clasificador débil correcto hemos de realizar un proceso de "aprendizaje"
    La idea es generar aleatoriamente A umbrales y utilizarlos para clasificar el conjunto 
    de aprendizaje. Finalmente, nos quedaremos con el umbral que mejor clasifique, es decir
    aquel que obtenga menor tasa de error para el conjunto dado. 





.............................................................................................
.............................................................................................
WeakSorter.java
    >> Dirección
    >> Umbral
    >> Pixel

StrongSorter.java
    >> Método Adaboost
    >> Métodos Enunciado

.............................................................................................
.............................................................................................
Adaboost (x , y)

    N = size(x);
    D(N) = 1 / N;   
    listaClasificadorDebil = {...}
    listaConfianza = {...}
    
    for( i = 0 >> T )
    {
        mejorClasificadorDebil = null;
        menorErr = INF;


        for( k = 0 >> A)
        {

            Pf = GenerarClasificadorAzar(DIMENSION);
            errK = obtenerErrorClasificador(Pf, 0, 0, D);
            
            if( errk < menorErr )
            {
                menorErr = errk;
                mejorClasificadorDebil = Pf;
            }
        }

        listaClasificadorDebil.add(mejorClasificadorDebil);
        a = o, s lm(1 - menorErr / menorErr);        
        listaConfianza.add(a);

        z = 0;

        auxD = D;
        
        for(i = 0 >> N)
        {
            exp = -1 * a * y[i].aplicarClasificadorDebil(mejorClasificadorDebil, x[i]);
            auxD[i] = nuevoPeso;
            z += nuevoPeso;
        }

        for( i = 0 >> N)
        {
            auxD[i] = auxD[i] / z;
        }

        D = auxD;
    }

return new (ClasificadorRobusto(listaClasificadorDebil, listaConfianzas));

.............................................................................................
.............................................................................................

>> generarClasificadorAzar(DIM)
   {
        pixel = rand(0 .. DIM);
        direcc = rand(1 .. 0);
        umbral = rand(min .. max); //0 .. 255
        
     return new ClasificadorDebil(pixel, direcc, umbral);
   }


>> obtenerErrClasif(Pf, x, y, D)
   {
        error = 0;
        for( i  = 0 >> size() )
        {                                               
            res = aplicarClasificadorDebil(Pf, x[i]); 
            if( res != y[i] )
            {
                error += D[i];
            }
        }

     return error;
   }

>> aplicarClasificadorDebil(Pf, imagen)
   {
        valido = -1;
        if(Pf. direccion)
        {
            if(imagen[pixel] <= Pf.umbral ) //umbral del clasificador
            {
                valido = 1;
            } 
        }
        else
        {
            if(imagen[pixel] > Pf.umbral )
            {
                valido = -1;
            }
        }

     return valido;
   }


























